 /***************************************************************************
  *   Copyright (C) 2024 by Federico Terraneo                               *
  *   Copyright (C) 2024 by Daniele Cattaneo                                *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  *   GNU General Public License for more details.                          *
  *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
  *   along with this program; if not, see <http://www.gnu.org/licenses/>   *
  ***************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include "exploit.h"
#include "FreeRTOS.h"
#include "task.h"
#include "peripherals.h"
#include "stm32f4xx_it.h"
#include "queue.h"

//Addresses for stm32f469i-disco
static char * const ptr=(char*)0xc0000000;     //Pointer to external RAM base address
static const unsigned int size=16*1024*1024;  //Size of external RAM
//Addresses for stm32f4discovery
// char *ptr=(char*)0x20000000; //Pointer to RAM base address
// unsigned int size=128*1024;  //Size of RAM

void sleeptask(void *p)
{
    puts("Sleeping");
    portSWITCH_TO_USER_MODE();
    for (;;) {
        HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
        vTaskDelay(1000);
    }
}

void fuzzpointers(void *p)
{
    puts("Fuzzing pointers");
    portSWITCH_TO_USER_MODE();
    //This test works as follows. A pointer is taken to the first byte of the
    //board RAM memory, something that can be easily gathered from the chip
    //programmer manual, and then the memset function is used to fill the entire
    //RAM memory with zeros. If the OS has memory protection, the fuzzer process
    //will segfault before it had the chance to write a single byte, preserving
    //system integrity. If the OS memory protection is broken/missing, this
    //program will cause a denial-of-service (DoS) attack crashing the kernel.
    //Failing this test demonstrates that a process has arbitrary memory write
    //capability, and is a proxy to demonstrate the possibility of implementing
    //kernel-level exploits.

    memset(ptr,0,size);
}

void fuzzsyscalls(void *p)
{
    puts("Fuzzing syscalls");
    portSWITCH_TO_USER_MODE();
    //This test works as follows. It calls certain syscalls that write to a
    //user-supplied pointer, passing a pointer outside the address space of the
    //process. If the kernel correctly validates pointers passed to syscalls,
    //then it will refuse to perform the syscall. If it does not, then this
    //opens up the possibility for a process to make writes to arbitrary memory
    //locations. This is here demonstrated with a denial of service attack (Dos)
    //by crashing the kernel, but is a proxy to demonstrate the possibility of
    //implementing kernel-level exploits.

    //Create a queue that somehow spans the entire RAM
    StaticQueue_t naughtyQueue;
    QueueHandle_t naughtyQueueHdl = xQueueCreateStatic(size/0x4, 0x4, ptr, &naughtyQueue);
    for (;;) {
        //uint32_t randomValue = 0xdeaddead;
        uint32_t randomValue = 0;
        xQueueSendToBack(naughtyQueueHdl, &randomValue, 0);
    }
}

void fuzzopcodes(void *p)
{
    puts("Fuzzing opcodes");
    portSWITCH_TO_USER_MODE();
    //This test works as follows. It inserts an illegal opcode in the code flow.
    //If the kernel correctly implements the abstraction of processes, only
    //the process will be segfaulted, otherwise this is another possibility for
    //a denial of service (DoS) attack crashing the entire kernel.
    
    asm volatile(".word 0xffffffff");
}

void fuzzbkpt(void *p)
{
    puts("Fuzzing breakpoints");
    portSWITCH_TO_USER_MODE();
    asm volatile("bkpt");
}


#define STACK_SIZE 8192
static StackType_t testTaskStack[STACK_SIZE/4] __attribute__((aligned(8192)));

typedef struct {
    StaticQueue_t queue;
    uint32_t queueBuf[2];
    QueueHandle_t queueHdl;
} t_blinkTaskShMem;
t_blinkTaskShMem blinkTaskShMem __attribute__((aligned(1024)));

void blinktask(void *p)
{
    puts("blink task started");
    portSWITCH_TO_USER_MODE();
    static const uint32_t one = 1;
    static const uint32_t zero = 0;
    xQueueSendToBack(blinkTaskShMem.queueHdl, &one, 1000000);
    vTaskDelay(1000);
    xQueueSendToBack(blinkTaskShMem.queueHdl, &zero, 1000000);
    vTaskDelay(1000);
    xQueueSendToBack(blinkTaskShMem.queueHdl, &one, 1000000);
    vTaskDelay(1000);
    xQueueSendToBack(blinkTaskShMem.queueHdl, &zero, 1000000);
    vTaskDelay(1000);
    for (;;) {
        xQueueSendToBack(blinkTaskShMem.queueHdl, &one, 1000000);
        xQueueSendToBack(blinkTaskShMem.queueHdl, &zero, 1000000);
    }
}

void blinkHost(void)
{
    blinkTaskShMem.queueHdl = xQueueCreateStatic(2, 0x4, (uint8_t *)blinkTaskShMem.queueBuf, &blinkTaskShMem.queue);
    TaskParameters_t taskParams =
    {
        .pvTaskCode     = blinktask,
        .pcName         = "test",
        .usStackDepth   = STACK_SIZE/4,
        .pvParameters   = NULL,
        .uxPriority     = 1 | portPRIVILEGE_BIT,
        .puxStackBuffer = testTaskStack,
        .xRegions       = {
            // note: if you use the tskMPU_REGION_xxx constants it WON'T work
            {&blinkTaskShMem, sizeof(t_blinkTaskShMem), portMPU_REGION_READ_WRITE},
            {0,0,0},{0,0,0}
        }
    };
    TaskHandle_t child;
    xTaskCreateRestricted(&taskParams, &child);
    for (;;) {
        uint32_t v;
        if (xQueueReceive(blinkTaskShMem.queueHdl, &v, 1000000) == pdPASS) {
            HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, v);
        }
    }
}

void fuzzer(void *unused)
{
    uint32_t oldCrash = *CRASH_REPORT_LOC;
    *CRASH_REPORT_LOC = CRASH_GOOD;
    switch (oldCrash) {
        case CRASH_BUS: puts("reboot after BusFault"); break;
        case CRASH_HARDFAULT: puts("reboot after HardFault"); break;
        case CRASH_NMI: puts("reboot after NMI"); break;
        case CRASH_USAGE: puts("reboot after UsageFault"); break;
        case CRASH_MEM_MANG: puts("reboot after MemMang"); break;
        case CRASH_FREERTOS_DEAD: puts("reboot after FreeRTOS kernel end"); break;
        default: puts("last reboot was normal");
    }

    for (;;) {
        puts("Where do you want to go today?");
        puts("0 : go to sleep");
        puts("1 : out of bound pointers");
        puts("2 : syscalls");
        puts("3 : illegal instructions");
        puts("4 : breakpoint instruction");
        puts("5 : process blinker");
        int fuzzoption=getchar()-'0';
        
        if (fuzzoption == 5) {
            blinkHost();
            continue;
        }

        void (*testfunc)(void *) = NULL;
        switch(fuzzoption)
        {
            case 0: testfunc=sleeptask; break;
            case 1: testfunc=fuzzpointers; break;
            case 2: testfunc=fuzzsyscalls; break;
            case 3: testfunc=fuzzopcodes; break;
            case 4: testfunc=fuzzbkpt; break;
            default:
                puts("wrong option selected");
        }
        if (testfunc) {
            TaskParameters_t taskParams =
            {
                .pvTaskCode     = testfunc,
                .pcName         = "test",
                .usStackDepth   = STACK_SIZE/4,
                .pvParameters   = NULL,
                .uxPriority     = 2 | portPRIVILEGE_BIT,
                .puxStackBuffer = testTaskStack,
                .xRegions       = {{0,0,0},{0,0,0},{0,0,0}}
            };
            TaskHandle_t child;
            xTaskCreateRestricted(&taskParams, &child);
            for (;;) {
                vTaskDelay(1000);
                puts("main task still alive");
                TaskStatus_t childStatus;
                vTaskGetInfo(child, &childStatus, pdFALSE, eInvalid);
                switch (childStatus.eCurrentState) {
                    case eRunning: puts("child is running"); break;
                    case eReady: puts("child is ready"); break;
                    case eBlocked: puts("child is blocked"); break;
                    case eSuspended: puts("child is suspended"); break;
                    case eDeleted: puts("child is deleted"); break;
                    default:
                    case eInvalid: puts("child is invalid"); break;
                }
            }
        }
        while (getchar() != '\n') ;
    }
}
