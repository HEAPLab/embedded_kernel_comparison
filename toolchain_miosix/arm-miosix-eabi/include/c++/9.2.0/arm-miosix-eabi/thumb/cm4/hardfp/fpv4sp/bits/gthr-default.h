
// RATIONALE: make the code generated by GCC thread safe by providing a thread model

#ifndef _GLIBCXX_GCC_GHTR_MIOSIX_H
#define _GLIBCXX_GCC_GHTR_MIOSIX_H

#include <pthread.h>
#include <unistd.h>
#include <sched.h>
#include <time.h>

//Note to self: gthr.h contains useful information
//on how a gthr-xxx.h should look like

#define __GTHREADS 1
#define __GTHREAD_HAS_COND 1
#define __GTHREADS_CXX0X 1
//Found in libstdc++
#define _GTHREAD_USE_MUTEX_TIMEDLOCK 1

//In Miosix, threads are always enabled, period.
#define __gthread_active_p() 1

typedef pthread_t       __gthread_t;
typedef pthread_key_t   __gthread_key_t; //This actually is unimplemented
typedef pthread_once_t  __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t  __gthread_cond_t;
typedef struct timespec __gthread_time_t;

#define __GTHREAD_ONCE_INIT                     PTHREAD_ONCE_INIT
#define __GTHREAD_MUTEX_INIT                    PTHREAD_MUTEX_INITIALIZER
#define __GTHREAD_MUTEX_INIT_FUNCTION           __gthread_mutex_init_function
#define __GTHREAD_RECURSIVE_MUTEX_INIT          PTHREAD_MUTEX_RECURSIVE_INITIALIZER_NP
#define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION __gthread_recursive_mutex_init_function
#define __GTHREAD_COND_INIT                     PTHREAD_COND_INITIALIZER
#define __GTHREAD_COND_INIT_FUNCTION            __gthread_cond_init_function
#define __GTHREAD_TIME_INIT                     {0,0}

#define __gthread_once                    pthread_once
#define __gthread_mutex_destroy           pthread_mutex_destroy
#define __gthread_recursive_mutex_destroy pthread_mutex_destroy
#define __gthread_cond_destroy            pthread_cond_destroy
#define __gthread_mutex_lock              pthread_mutex_lock
#define __gthread_mutex_trylock           pthread_mutex_trylock
#define __gthread_mutex_unlock            pthread_mutex_unlock
#define __gthread_recursive_mutex_lock    pthread_mutex_lock
#define __gthread_recursive_mutex_trylock pthread_mutex_trylock
#define __gthread_recursive_mutex_unlock  pthread_mutex_unlock
#define __gthread_cond_signal             pthread_cond_signal
#define __gthread_cond_broadcast          pthread_cond_broadcast
#define __gthread_cond_wait               pthread_cond_wait
#define __gthread_cond_wait_recursive     pthread_cond_wait
#define __gthread_join                    pthread_join
#define __gthread_detach                  pthread_detach
#define __gthread_equal                   pthread_equal
#define __gthread_self                    pthread_self
#define __gthread_yield                   sched_yield

//These actually aren't implemented in Miosix, so code trying to use these will
//fail to link, and for now it's the "desired" behaviour (better than failing
//at runtime, at least). They are used somewhere in libstdc++ too, but it can
//be patched to remove those uses.
#define __gthread_key_create                pthread_key_create
#define __gthread_key_delete                pthread_key_delete
#define __gthread_getspecific               pthread_getspecific
#define __gthread_setspecific               pthread_setspecific
#define __gthread_mutex_timedlock           pthread_mutex_timedlock
#define __gthread_recursive_mutex_timedlock pthread_mutex_timedlock
#define __gthread_cond_timedwait            pthread_cond_timedwait

static inline void __gthread_mutex_init_function(__gthread_mutex_t *__mutex)
{
    pthread_mutex_init(__mutex, NULL);
}

static inline void __gthread_recursive_mutex_init_function(__gthread_recursive_mutex_t *__mutex)
{
    //Defined in newlib patches for Miosix
    __lock_init_recursive(*__mutex);
}

static inline void __gthread_cond_init_function(__gthread_cond_t *__cond)
{
    pthread_cond_init(__cond, NULL);
}

static inline int __gthread_create(__gthread_t *__thrd, void *(*__func)(void*), void *__args)
{
    return pthread_create(__thrd, NULL, __func, __args);
}

#endif //_GLIBCXX_GCC_GHTR_MIOSIX_H
